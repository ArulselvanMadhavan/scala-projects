import fp.functional_data_structures.List

object test{
    def main(args:Array[String]):Unit = {
        println(List.sum(List(2,3,4)))
        println(List.product(List(4,5,6)))
        val after_1:List[Int] = List.tail(List(1,2)).getOrElse(List())
        println(s"After Ã§alling tail once $after_1")
        val after_2:List[Int] = List.tail(after_1).getOrElse(List())
        println(s"After calling tail twice $after_2")
        val h1:List[Int] = List.setHead(after_2, 100)
        println(s"After calling setHead once $h1")
        val h2:List[Int] = List.setHead(List(3,4,5,56), 200)
        println(s"After calling setHead on a new list $h2")
        val d1:List[Int] = List.drop(List(2,3,4,5,6,7,7,8,8), 4)
        println(s"After dropping $d1")
        val d2:List[Int] = List.drop(d1, 10)
        println(s"After dropping $d2")
        val isTwo = (x:Int) => (x == 2)
        val dw1 = List.dropWhile(List(2,2,5,2,2,3,4,2,5), isTwo)
        println(dw1)
        val i1 = List.init(List(2,3,4,5,6))
        println(s"Init result $i1")
        val fr1 = List.foldRight(List(2,3,4,5,6), 1)((x,y) => x * y)
        println(s"foldRight product $fr1")
        val len1 = List.foldRight(List(2,3,3,3,3,3), 0)((x, y) => 1 + y)
        println(s"Length of list $len1")
        val fl1 = List.foldLeft(List(2,3,4,5,6), 1)((x,y) => x * y)
        println(s"foldLeft product $fl1")
        val sum_fl = List.foldLeft(List(2,3,4,5,5), 0)((x,y) => x + y)
        println(s"foldLeft sum $sum_fl")
        val prod_fl = List.foldLeft(List(3,3,3,3,3), 1)((x,y) => x * y)
        println(s"foldLeft prod $prod_fl")
        val rev = List.reverse(List(4,4,5,6,1,2,3))
        println(s"Reversed list $rev")
        val app1 = List.append(List(3,4,5,6,7), List(8,9,10))
        println(s"Append $app1")
        val row1 = List(1,2,3)
        val row2 = List(4,5,6)
        val row3 = List(7,8,9)
        val ll = List(row1, row2, row3)
        val conc = List.concatenate(ll)
        println(s"Concatenated list $conc")
    }
}